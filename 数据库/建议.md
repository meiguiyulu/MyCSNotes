### 建议

#### MySQL高性能优化规范建议

[链接](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN%23rd)

##### 数据库命令规范

> 所有数据库对象名称必须使用小写字母并用下划线分割
>
> 所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）•数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符
>
> 临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀
>
> 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）

##### 数据库基本设计规范

1. 所有表必须使用 Innodb 存储引擎

> 没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。
>
> Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。

2. 数据库和表的字符集统一使用 UTF8

>  兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。

3. 所有表和字段都需要添加注释

>  使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护

4. 尽量控制单表数据量的大小,建议控制在 500 万以内。

> 500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。
>
> 可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小

5. 谨慎使用 MySQL 分区表

>  分区表在物理上表现为多个文件，在逻辑上表现为一个表；
>
> 谨慎选择分区键，跨分区查询效率可能更低；
>
> 建议采用物理分表的方式管理大数据。

6.尽量做到冷热数据分离,减小表的宽度

> MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。
>
> 减少磁盘 IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）；
>
> 更有效的利用缓存，避免读入无用的冷数据；
>
> 经常一起使用的列放到一个表中（避免更多的关联操作）。

7. 禁止在表中建立预留字段

> 预留字段的命名很难做到见名识义。
>
> 预留字段无法确认存储的数据类型，所以无法选择合适的类型。
>
> 对预留字段类型的修改，会对表进行锁定。

8. 禁止在数据库中存储图片,文件等大的二进制数据

> 通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。
>
> 通常存储于文件服务器，数据库只存储文件地址信息

9. 禁止在线上做数据库压力测试

10. 禁止从开发环境,测试环境直接连接生成环境数据库

#### 书写高质量SQL的30条建议

[链接](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486461&idx=1&sn=60a22279196d084cc398936fe3b37772&chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&token=1987003517&lang=zh_CN%23rd)

##### 查询SQL尽量不要使用select *，而是select具体字段。

![image-20210412112852737](image/image-20210412112852737.png)

> - 只取需要的字段，节省资源、减少网络开销。
> - select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。

##### 如果知道查询结果只有一条或者只要最大/最小一条记录，建议用limit 1

> - 加上limit 1后,只要找到了对应的一条记录,就不会继续向下扫描了,效率将会大大提高。
> - 当然，如果name是唯一索引的话，是不必要加上limit 1了，因为limit的存在主要就是为了防止全表扫描，从而提高性能,如果一个语句本身可以预知不用全表扫描，有没有limit ，性能的差别并不大。

![image-20210412112912337](image/image-20210412112912337.png)

##### 应尽量避免在where子句中使用or来连接条件

