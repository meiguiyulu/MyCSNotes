# 分布式

## 1、基础概念

- **集群**

  - ```markdown
    **
    `不同服务器部署同一套应用服务对外提供访问`，以实现服务的负载均衡或者互备(热备，主从等)。是同一种组件的多个实例，形成的逻辑上的整体。`单个节点可以提供完整服务`。
    集群是物理形态。
    ```

- **分布式**

  - ```markdown
    **
    `服务的不同模块部署在不同的服务器上，单个节点不能提供完整服务，需要多节点协调提供服务`(也可以是相同组件部署在不同节点、但节点间通过交换信息协作提供服务)。
    分布式强调的是工作方式
    ```

- **SOA**

  - ```markdown
    **
    面向服务的架构，一种设计方法，其中包含多个服务， 服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在于操作系统进程中。各个服务之间通过网络调用。
    ```

- **微服务**

  - ```markdown
    **
    在 SOA 上做的升华，微服务架构强调的一个重点是业务需要彻底的组件化和服务化，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。
    ```
  
- **`CAP`**

  - ```markdown
    **
    CAP原则又称CAP定理，指的是在一个分布式系统中，`一致性(Consistency)`、`可用性(Availability)`、`分区容错性(Partition tolerance)`。
    > CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。
    	CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时C和P两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足
    1. 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）
    2. 可用性（A）：保证每个请求不管成功或者失败都有响应。
    3. 分区容忍性（P）：系统中任意信息的丢失或失败不会影响系统的继续运作
    
    ```

  - 

https://blog.csdn.net/u014590757/article/details/80100085

https://zhuanlan.zhihu.com/p/103851491?utm_source=wechat_session&utm_medium=social&s_r=0

## 分布式事务

​		分布式事务用于在分布式系统中保证不同节点之间的数据一致性。分布式事务的实现有很多种，最具有代表性的是由**Oracle Tuxedo**系统提出的**XA**分布式事务协议。

​		XA协议包含**两阶段提交（2PC）**和**三阶段提交（3PC）**两种实现。

### 两阶段提交(2PC)

​		2PC（Two-phase commit protocol），中文叫二阶段提交。 **二阶段提交是一种强一致性设计**，2PC 引入一个**事务协调者**的角色来协调管理各参与者（也可称之为各本地资源）的提交和回滚，二阶段分别指的是准备（投票）和提交两个阶段。

#### 第一阶段

![image-20210911155927658](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210911155927658.png)

**`2PC`** 的第一阶段，作为事务协调者的节点会首先向所有的参与者节点发送 `Prepare` 请求。

在接到 `Prepare `请求之后，每一个参与者节点会各自执行与事务有关的数据更新，写入 `Undo Log `和 `Redo Log`。如果参与者执行成功，暂时不提交事务，而是向事务协调节点返回“完成”消息。

当事务协调者接到了所有参与者的返回消息，整个分布式事务将会进入第二阶段。

#### 第二阶段

![image-20210911160204416](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210911160204416.png)

在 **`2PC`** 的第二阶段，如果事务协调节点在之前所收到都是正向返回，那么它将会向所有事务参与者发出 `Commit` 请求。

接到 `Commit` 请求之后，事务参与者节点会各自进行本地的事务提交，并释放锁资源。当本地事务完成提交后，将会向事务协调者返回“完成”消息。

当事务协调者接收到所有事务参与者的“完成”反馈，整个分布式事务完成。

#### 失败案例

##### 第一阶段失败

- **第一阶段：**
  - ![image-20210911160626067](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210911160626067.png)
  - 假如在第一阶段有一个参与者返回失败，那么协调者就会向所有参与者发送回滚事务的请求，即分布式事务执行失败。
- **第二阶段**
  - ![image-20210911160648063](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210911160648063.png)
  - 于是在第二阶段，事务协调节点向所有的事务参与者发送 `Abort `请求。接收到 `Abort` 请求之后，各个事务参与者节点需要在本地进行事务的回滚操作，回滚操作依照 `Undo Log` 来进行。

##### 第二阶段失败

有两种情况：

- 第一种是**第二阶段执行的是回滚事务操作**，那么答案是不断重试，直到所有参与者都回滚了，不然那些在第一阶段准备成功的参与者会一直阻塞着。
- 第二种是**第二阶段执行的是提交事务操作**，那么答案也是不断重试，因为有可能一些参与者的事务已经提交成功了，这个时候只有一条路，就是头铁往前冲，不断的重试，直到提交成功，到最后真的不行只能人工介入处理。

#### 细节信息

首先 2PC 是一个**同步阻塞协议**，像第一阶段协调者会等待所有参与者响应才会进行下一步操作，当然第一阶段的**协调者有超时机制**，假设因为网络原因没有收到某参与者的响应或某参与者挂了，那么超时后就会判断事务失败，向所有参与者发送回滚命令。

在第二阶段协调者的没法超时，因为按照我们上面分析只能不断重试！

#### 协调者故障分析

**协调者是一个单点，存在单点故障问题**

- 假设协调者在**发送准备命令之前**挂了，还行等于事务还没开始。
- 假设协调者在**发送准备命令之后**挂了，这就不太行了，有些参与者等于都执行了处于事务资源锁定的状态。不仅事务执行不下去，还会因为锁定了一些公共资源而阻塞系统其它操作。
- 假设协调者在**发送回滚事务命令之前**挂了，那么事务也是执行不下去，且在第一阶段那些准备成功参与者都阻塞着。
- 假设协调者在**发送回滚事务命令之后**挂了，这个还行，至少命令发出去了，很大的概率都会回滚成功，资源都会释放。但是如果出现网络分区问题，某些参与者将因为收不到命令而阻塞着。
- 假设协调者在**发送提交事务命令之前**挂了，这个不行，傻了！这下是所有资源都阻塞着。
- 假设协调者在**发送提交事务命令之后**挂了，这个还行，也是至少命令发出去了，很大概率都会提交成功，然后释放资源，但是如果出现网络分区问题某些参与者将因为收不到命令而阻塞着。

**协调者故障，通过选举得到新协调者**

因为协调者单点问题，因此我们可以通过选举等操作选出一个新协调者来顶替。

- 如果处于第一阶段，其实影响不大都回滚好了，在第一阶段事务肯定还没提交。
- 如果处于第二阶段
  - 假设参与者都没挂，此时新协调者可以向所有参与者确认它们自身情况来推断下一步的操作。
  - 假设有个别参与者挂了！这就有点僵硬了，比如协调者发送了回滚命令，此时第一个参与者收到了并执行，然后协调者和第一个参与者都挂了。此时其他参与者都没收到请求，然后新协调者来了，它询问其他参与者都说OK，但它不知道挂了的那个参与者到底O不OK，所以它傻了。
  - 问题其实就出在**每个参与者自身的状态只有自己和协调者知道**，因此新协调者无法通过在场的参与者的状态推断出挂了的参与者是什么情况。

#### 总结

`2PC` 是一种**尽量保证强一致性**的分布式事务，因此它是**同步阻塞**的，而同步阻塞就导致长久的资源锁定问题，**总体而言效率低**，并且存在**单点故障**问题，在极端条件下存在**数据不一致**的风险。

当然具体的实现可以变形，而且 2PC 也有变种，例如 Tree 2PC、Dynamic 2PC。

还有一点不知道你们看出来没，2PC 适用于**数据库层面的分布式事务场景**，而我们业务需求有时候不仅仅关乎数据库，也有可能是上传一张图片或者发送一条短信。

### 三阶段提交(3PC)

#### 过程分析

3PC 的出现是为了解决 2PC 的一些问题，相比于 2PC 它在**参与者中也引入了超时机制**，并且**新增了一个阶段**使得参与者可以利用这一个阶段统一各自的状态。

3PC 包含了三个阶段，分别是**准备阶段、预提交阶段和提交阶段**，对应的英文就是：`CanCommit、PreCommit 和 DoCommit`。

**把 2PC 的提交阶段变成了预提交阶段和提交阶段**，但是 3PC 的准备阶段协调者只是询问参与者的自身状况，比如你现在还好吗？负载重不重？这类的。

![image-20210911162632917](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210911162632917.png)

不管哪一个阶段有参与者返回失败都会宣布事务失败，这和 `2PC` 是一样的（当然到最后的提交阶段和 `2PC` 一样只要是提交请求就只能不断重试）。

首先**准备阶段的变更成不会直接执行事务**，而是会先去询问此时的参与者是否有条件接这个事务，因此**不会一来就干活直接锁资源**，使得在某些资源不可用的情况下所有参与者都阻塞着。

而**预提交阶段的引入起到了一个统一状态的作用**，它像一道栅栏，表明在预提交阶段前所有参与者其实还未都回应，在预处理阶段表明所有参与者都已经回应了。

假如你是一位参与者，你知道自己进入了预提交状态那你就可以推断出来其他参与者也都进入了预提交状态。

但是多引入一个阶段也多一个交互，因此**性能会差一些**，而且**绝大部分的情况下资源应该都是可用的**，这样等于每次明知可用执行还得询问一次。

#### 参与者超时

我们知道 2PC 是同步阻塞的，上面我们已经分析了协调者挂在了提交请求还未发出去的时候是最伤的，所有参与者都已经锁定资源并且阻塞等待着。

那么引入了超时机制，参与者就不会傻等了，**如果是等待提交命令超时，那么参与者就会提交事务了**，因为都到了这一阶段了大概率是提交的，**如果是等待预提交命令超时，那该干啥就干啥了，反正本来啥也没干**。

然而超时机制也会带来数据不一致的问题，比如在等待提交命令时候超时了，参与者默认执行的是提交事务操作，但是**有可能执行的是回滚操作，这样一来数据就不一致了**。

**当然 3PC 协调者超时还是在的，具体不分析了和 2PC 是一样的。**

#### 总结

从维基百科上看，3PC 的引入是为了解决提交阶段 2PC 协调者和某参与者都挂了之后新选举的协调者不知道当前应该提交还是回滚的问题。

新协调者来的时候发现有一个参与者处于预提交或者提交阶段，那么表明已经经过了所有参与者的确认了，所以此时执行的就是提交命令。

所以说 3PC 就是通过引入预提交阶段来使得参与者之间的状态得到统一，也就是留了一个阶段让大家同步一下。

但是这也只能让协调者知道该如何做，但不能保证这样做一定对，这其实和上面 2PC 分析一致，因为挂了的参与者到底有没有执行事务无法断定。

所以说 3PC 通过预提交阶段可以减少故障恢复时候的复杂性，但是不能保证数据一致，除非挂了的那个参与者恢复。

让我们总结一下， 3PC 相对于 2PC 做了一定的改进：**引入了参与者超时机制，并且增加了预提交阶段使得故障恢复之后协调者的决策复杂度降低，但整体的交互过程更长了，性能有所下降，并且还是会存在数据不一致问题。**

所以 2PC 和 3PC 都不能保证数据100%一致，因此一般都需要有**定时扫描补偿机制**。

我再说下 3PC 我没有找到具体的实现，所以我认为 3PC 只是纯的理论上的东西，而且可以看到相比于 2PC 它是做了一些努力但是效果甚微，所以只做了解即可。



### TCC

**2PC 和 3PC 都是数据库层面的，而 TCC 是业务层面的分布式事务**，就像我前面说的分布式事务不仅仅包括数据库的操作，还包括发送短信等，这时候 TCC 就派上用场了！

TCC 指的是`Try - Confirm - Cancel`。

- `Try` 指的是预留，即资源的预留和锁定，**注意是预留**。
- `Confirm` 指的是确认操作，这一步其实就是**真正的执行**了。
- `Cancel` 指的是撤销操作，可以理解为**把预留阶段的动作撤销**了。

其实从思想上看和 2PC 差不多，都是先试探性的执行，如果都可以那就真正的执行，如果不行就回滚。

比如说一个事务要执行A、B、C三个操作，那么先对三个操作执行预留动作。如果都预留成功了那么就执行确认操作，如果有一个预留失败那就都执行撤销动作。

我们来看下流程，TCC模型还有个事务管理者的角色，用来记录TCC全局事务状态并提交或者回滚事务。

![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/v2-90179fa933c0a389ffa6ac04e244a58f_720w.jpg)

可以看到流程还是很简单的，难点在于业务上的定义，对于每一个操作你都需要定义三个动作分别对应`Try - Confirm - Cancel`。

因此 **TCC 对业务的侵入较大和业务紧耦合**，需要根据特定的场景和业务逻辑来设计相应的操作。

还有一点要注意，撤销和确认操作的执行可能需要重试，因此还需要保证**操作的幂等**。

相对于 2PC、3PC ，TCC 适用的范围更大，但是开发量也更大，毕竟都在业务上实现，而且有时候你会发现这三个方法还真不好写。不过也因为是在业务上实现的，所以**TCC可以跨数据库、跨不同的业务系统来实现事务**。

### 本地消息表

本地消息表其实就是利用了 **各系统本地的事务** 来实现分布式事务。

本地消息表顾名思义就是会有一张存放本地消息的表，一般都是放在数据库中，然后在执行业务的时候 **将业务的执行和将消息放入消息表中的操作放在同一个事务中**，这样就能保证消息放入本地表中业务肯定是执行成功的。

然后再去调用下一个操作，如果下一个操作调用成功了好说，消息表的消息状态可以直接改成已成功。

如果调用失败也没事，会有 **后台任务定时去读取本地消息表**，筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态。

这时候有可能消息对应的操作不成功，因此也需要重试，重试就得保证对应服务的方法是幂等的，而且一般重试会有最大次数，超过最大次数可以记录下报警让人工处理。

可以看到本地消息表其实实现的是**最终一致性**，容忍了数据暂时不一致的情况。

### 消息事务

`RocketMQ` 就很好的支持了消息事务，让我们来看一下如何通过消息实现事务。

第一步先给 `Broker` 发送事务消息即半消息，**半消息不是说一半消息，而是这个消息对消费者来说不可见**，然后**发送成功后发送方再执行本地事务**。

再根据**本地事务的结果向 Broker 发送 `Commit` 或者 `RollBack` 命令**。

并且 `RocketMQ` 的发送方会提供一个**反查事务状态接口**，如果一段时间内半消息没有收到任何操作请求，那么 `Broker` 会通过反查接口得知发送方事务是否执行成功，然后执行 `Commit `或者 `RollBack` 命令。

如果是 `Commit` 那么订阅方就能收到这条消息，然后再做对应的操作，做完了之后再消费这条消息即可。

如果是 `RollBack` 那么订阅方收不到这条消息，等于事务就没执行过。

可以看到通过 `RocketMQ` 还是比较容易实现的，`RocketMQ` 提供了事务消息的功能，我们只需要定义好事务反查接口即可。

![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/v2-72ba7bed684e855606c44ddda185987d_720w.jpg)

可以看到消息事务实现的也是最终一致性。

### 最大努力通知

其实我觉得本地消息表也可以算最大努力，事务消息也可以算最大努力。

就本地消息表来说会有后台任务定时去查看未完成的消息，然后去调用对应的服务，当一个消息多次调用都失败的时候可以记录下然后引入人工，或者直接舍弃。这其实算是最大努力了。

事务消息也是一样，当半消息被 `commit` 了之后确实就是普通消息了，如果订阅者一直不消费或者消费不了则会一直重试，到最后进入死信队列。其实这也算最大努力。

所以**最大努力通知其实只是表明了一种柔性事务的思想**：我已经尽力我最大的努力想达成事务的最终一致了。

适用于对时间不敏感的业务，例如短信通知。

### 总结

可以看出 `2PC` 和 `3PC` 是一种强一致性事务，不过还是有数据不一致，阻塞等风险，而且只能用在数据库层面。

而 `TCC` 是一种补偿性事务思想，适用的范围更广，在业务层面实现，因此对业务的侵入性较大，每一个操作都需要实现对应的三个方法。

本地消息、事务消息和最大努力通知其实都是最终一致性事务，因此适用于一些对时间不敏感的业务。
