### JVM

> JVM它是Java Virtual Machine 的缩写, Java虚拟机。

#### ==内存（运行时数据区）==

![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGQzYjE1YjNkODgyNmZhZWFlMjA2Mzk3NmZiOTkyMTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

- JVM初始运行的时候都会分配好**Method Area（方法区）**和**Heap（堆）**
- JVM 每遇到一个线程，就为其分配一个**Program Counter Register（程序计数器）**, **VM Stack（虚拟机栈）和Native Method Stack （本地方法栈）**
- 当**线程终止**时，三者（**虚拟机栈，本地方法栈和程序计数器**）所占用的内存空间也会被释放掉，非线程共享的那三个区域的生命周期与所属线程相同。
- 而**线程共享的区域与JAVA程序运行的生命周期相同**，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因。		

##### 程序计数器

> 线程私有

> 程序执行的位置。字节码解释器工作时通过改变这个计数器的值来选取**下一条**需要执行的指令等(分支、循环、跳转、异常处理、线程恢复等)。
>
> 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在指向的是Native方法，这个计数器为空(Undefined)。
>
> **唯一一个不会出现OutOfMemoryError**的内存区域。

###### 程序计数器和指令寄存器

电脑执行程序的过程就是cpu不断执行指令的过程。cpu执行指令的过程，第一步就是取指令，并将其放入**指令寄存器**，然后对指令译码，进行一些操作，最后计算下条指令的地址，并送入**程序计数器。**总之，**一个用来存当前指令**，一个用来存**下条指令的地址**。cpu根据程序计数器里的地址取指令，将取到的指令送指令寄存器。

寄存器是[中央处理器](https://baike.baidu.com/item/中央处理器/284033)内的组成部分。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存[指令](https://baike.baidu.com/item/指令/3225201)、[数据](https://baike.baidu.com/item/数据/33305)和[地址](https://baike.baidu.com/item/地址/80420)。在[中央处理器](https://baike.baidu.com/item/中央处理器/284033)的控制部件中，包含的寄存器有[指令寄存器](https://baike.baidu.com/item/指令寄存器/3219483)(IR)和[程序计数器](https://baike.baidu.com/item/程序计数器/3219536)(PC)。

- 指令寄存器（instruction register）- 储存现在正在被运行的指令。
- 程序计数器（Program Counter Register）是一块较小的内存空间，它存储的是下一条指令所在单元的地址。

##### 虚拟机栈

> 线程私有

> 实际上，Java是由一个个`栈帧`组成的，每个`栈帧`都拥有：局部变量表、操作数栈、动态链接、方法出口信息。
>
> > 局部变量表主要存放的是：**编译器可知的各种数据类型(boolean, byte, char, short, int, float, long, double)、对象引用(reference 类型。可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他于此对象相关的信息)**也有可能是returnAddress类型(指向一条字节码指令的地址)。

> 会出现的两种异常：**StackOverFlowError和OutOfMemoryError**。
>
> > **StackOverFlowError:** 若Java虚拟机的内存大小**不允许**动态扩展，那么当线程请求栈的深度超过当前Java虚拟机的最大深度的时候，就抛出此异常。
> >
> > **OutOfMemoryError: **若Java虚拟机的内存大小**允许**动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，就抛出此异常。

==个人理解：这个地方存储的是平时程序中定义的变量、指针等。程序开始，在虚拟机栈内分布内存；程序结束, 删除内存。==

##### 本地方法栈

> `Native Method Stack`
>
> 线程私有

> 为虚拟机使用到的**Native**方法服务
>
> `Native方法`
>
> > 非Java语言实现的方法，例如C++、C等实现。
>
> 本地方法栈区域也会抛出 `StackOverflowError` 和 `OutOfMemoryError` 异常

##### 堆

> 线程共享

> 在虚拟机启动时创建，唯一目的：**存放对象实例，所有的对象实例以及数组都在这里分配**。所有new出来的对象都存储在该区域。

**==与虚拟机栈不同，堆中存放的对象不会因为程序的结束而删除。只能通过垃圾回收(GC)。==**

- `-Xmx(-XX:MaxHeapSize)：最大堆大小`
- `-Xms(-XX:InitialHeapSize)：初始堆大小`
- `-XX:NewSize: 新生代初始大小`
- `-Xmn(-XX:MaxNewSize): 年轻代最大大小`
- `-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值`
- `-XX:NewRatio：指定老年代/新生代的内存比例`
- `-XX:OldSize：设置JVM启动分配的老年代内存大小`
- `-XX:PermSize` 和 `-XX:MaxPermSize：指定JVM中的永久代(方法区)的大小`

##### 方法区

> 线程共享
>
> 存放：静态变量 + 常量 + 类信息(构造方法/接口定义) + 运行时常量池。

`方法区和永久代`

> 方法区和永久代 的关系就像类和接口的关系，类实现了接口，而永久代就是HotSpot虚拟机堆虚拟机规范中的一种实现方式。方法区是一种规范，永久代是一种实现。

###### 运行时常量池

![image-20210405211329308](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210405211329308.png)

###### 常用参数

```java
-XX:PermSize=N //方法区(永久代)初始大小
-XX:MaxPermSize=N //方法区(永久代)最大大小，超出这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen
```

JDK 1.8以后，方法区被彻底移除，取而代之的是元空间，使用的是**直接内存**。

```java
-XX:MetaspaceSize=N //设置Metaspace初始大小(最小大小)
-XX:MaxMetaspaceSize=N //设置Metaspace的最大大小
```

###### 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?

![image-20210402184426295](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210402184426295.png)

###### 直接内存

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域。**但是这部分内存也被频繁地使用，而且也可能导致`OutOfMemoryError`异常出现。

> ![image-20210402192410762](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210402192410762.png)

直接内存的分配不会受到Java堆的限制，但是，既然是内存，就会受到**本机内存大小以及处理器寻址空间的限制**。

##### **逃逸分析**

这个知识点来源于看到的一个问题：**Java中的对象都是在堆中分配吗？**。

几乎所有的对象在堆中进行分配，这个是大家经常看到的一句话，但是这句话中并不意味着所有，JVM中对象是可以在栈中进行分配，但是前提是需要判断逃逸状态。

###### **Java对象内存分配策略**

一般认为，Java对象都是在堆上分配的，但也有一些特殊情况。Java对象内存分配策略：

![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/20190420173121975.png)

在Java中，典型的对象不在堆上分配的情况有两种：TLAB（Thread Local Allocation Buffer）和栈上分配（严格来说TLAB也是属于堆，只是在TLAB比较特殊）。

###### **一 、栈上分配**

​		JVM在Server模式下的逃逸分析可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是**对于某些未逃逸对象可以直接在栈上分配，由于该对象一定是局部的，所以栈上分配不会有问题。**在实际的应用程序，尤其是大型程序中反而发现实施逃逸分析可能出现效果不稳定的情况，或因分析过程耗时但却无法有效判别出非逃逸对象而导致性能（即时编译的收益）有所下降，所以在很长的一段时间里，即使是Server Compiler，也默认不开启逃逸分析，甚至在某些版本（如JDK 1.6 Update18）中还曾经短暂地完全禁止了这项优化。

###### **二 、TLAB分配**

​		对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。

​		解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS和失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（`Thread Local Allocation Buffer, TLAB`）。

​		**JVM在内存新生代Eden Space中开辟了一小块区域，由线程私有，称作TLAB（Thread-local allocation buffer），默认设定为占用Eden Space的1%**。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。

​		哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过 ``-XX:+/-UseTLAB` 参数来设定。通常默认的TLAB区域大小是Eden区域的1%，当然也可以手工进行调整，对应的JVM参数是 `-XX:TLABWasteTargetPercent`。

###### **三、为什么不直接在堆上分配？**

我们知道堆是由所有线程共享的，既然如此那它就是竞争资源，对于竞争资源，必须采取必要的同步，所以当使用new关键字在堆上分配对象时，是需要锁的。既然有锁，就必定存在锁带来的开销，而且由于是对整个堆加锁，相对而言锁的粒度还是比较大的，影响效率。而无论是TLAB还是栈都是线程私有的，私有即避免了竞争。

所以对于某些特殊情况，可以采取避免在堆上分配对象的办法，以提高对象创建和销毁的效率。

######  **四、对象内存分配的两种方法**

为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。

1） 指针碰撞(Serial、ParNew等带Compact过程的收集器)

假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump the Pointer）。

2）空闲列表(CMS这种基于Mark-Sweep算法的收集器)

如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。

选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。



###### **什么是逃逸分析？**

逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。

逃逸分析的 JVM 参数如下：

- 开启逃逸分析：`-XX:+DoEscapeAnalysis`
- 关闭逃逸分析：`-XX:-DoEscapeAnalysis`
- 显示分析结果：`-XX:+PrintEscapeAnalysis`

###### **对象的逃逸状态**

1. **全局逃逸(Gloabal Escape)**

   即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：

   - 对象是一个静态变量
   - 对象是一个已经发生逃逸的对象
   - 对象作为当前方法的返回值

2. **参数逃逸(Arg Escape)**

   即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。

3. **没有逃逸**

   即方法中的对象没有发生逃逸。

###### **逃逸分析优化**

针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化。

**1) 锁消除**

我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。

例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。

锁消除的 JVM 参数如下：

- 开启锁消除：-XX:+EliminateLocks
- 关闭锁消除：-XX:-EliminateLocks

锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。

**2) 标量替换**

首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。

对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。

这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。

标量替换的 JVM 参数如下：

- 开启标量替换：-XX:+EliminateAllocations
- 关闭标量替换：-XX:-EliminateAllocations
- 显示标量替换详情：-XX:+PrintEliminateAllocations

标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。

**3) 栈上分配**

当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。

****************

#### JVM运行原理

**举例**

> ```java
> public class JVMShowcase {
>     //静态类常量,
>     public final static String ClASS_CONST = "I'm a Const";
>     //私有实例变量
>     private int instanceVar=15;
>     public static void main(String[] args) {
>         //调用静态方法
>         runStaticMethod();
>         //调用非静态方法
>         JVMShowcase showcase=new JVMShowcase();
>         showcase.runNonStaticMethod(100);
>     }
>     //常规静态方法
>     public static String runStaticMethod(){
>         return ClASS_CONST;
>     }
>     //非静态方法
>     public int runNonStaticMethod(int parameter){
>         int methodVar=this.instanceVar * parameter;
>         return methodVar;
>     }
> }
> ```

**第 1 步** 、向操作系统申请空闲内存。JVM 向操作系统申请空闲内存作系统就查找自己的内存分配表，找了段内存写上“Java 占用”标签，然后把内存段的起始地址和终止地址给 JVM，JVM 准备加载类文件。

**第 2 步，** JVM 分配内存。JVM 获得到内存后，就开始得瑟了，首先给 heap 分配内存，然后给栈内存也分配好。

**第 3 步，**文件检查和分析class 文件。若发现有错误即返回错误。

**第 4 步，**加载类。由于没有指定加载器，JVM 默认使用 bootstrap 加载器。所有类都加载到了堆类存的Method Area，JVMShow 也被加载到内存中。我们来看看Method Area区域，如下图：（**这时候包含了 main 方法和 runStaticMethod方法的符号引用，因为它们都是静态方法，在类加载的时候就会加载**）

Heap 是空，Stack 是空，因为还没有对象的新建和线程被执行。

**第 5 步、**执行方法。**执行 main 方法。执行启动一个线程，开始执行 main 方法，在 main 执行完毕前，方法区如下图所示：（**public final static String ClASS_CONST = "I'm a Const";  ）

在 Method Area 加入了 CLASS_CONST 常量，它是在第一次被访问时产生的（runStaticMethod方法内部）。

**第 6 步，**释放内存。

********

#### Java对象创建过程

![image-20210403132558685](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210403132558685.png)

类加载检查：虚拟机遇到一条`new`指令时，首先去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。

分配内存：在类加载通过时，接下来虚拟机将为新生对象分配内存。分配方式有**“指针碰撞”和“空闲列表”两种，选择那种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。**

![image-20210405211540044](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210405211540044.png)

**内存分配并发问题**

- 在创建对象的时候，有一个很重要的问题，就是线程安全。因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

  - ​	CAS+失败重试：CAS是乐观锁的一种实现方式。所谓乐观锁就是，**每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。
  - ​	TLAB：**为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配**。

- 初始化零值：

  内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一操作保证对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型对应的零值。

- 设置对象头：初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

- 执行`init`方法：在上面工作都完成之后，**从虚拟机的视角来看，一个新的对象已经产生了，但从Java 程序的视角来看，对象创建才刚开始，`<init>`方法还没有执行，所有的字段都还为零。**所以一般来说，执行new指令之后会接着执行`<init>`方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

***********

**************

#### 对象的访问方式有哪两种

建立对象就是为了访问对象，我们的Java程序通过栈上的*reference*数据来操作堆上的具体对象。访问方式由虚拟机实现而定，目前主流的访问方式有**使用句柄**和**直接指针**两种。

1. 句柄：如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

   ![image-20210405214211797](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210405214211797.png)

2. 直接指针：如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。

![image-20210405214302725](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210405214302725.png)

这两种对象访问方式各有优势。**使用句柄来访问的最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**

#### 堆内存中对象分配的基本策略

##### ==**堆空间的基本结构**==

![image-20210406144121315](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210406144121315.png)

​		图所示的eden区、s0区、s1区都属于新生代，tentired区属于老年代。大部分情况，对象都会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s0或者s1，并且对象的年龄还会加1（Eden区$\rightarrow$Survivor区后对象的初始年龄变为1），当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数`-XX:MaxTenuringThreshold `来设置。

```markdown
1. 为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年级必须达到MaxTenuringThreshold才能进入老年代。
2. 如果在Survivior空间中相同年龄所有对象大小的总和大于Survivior空间的一半，年龄大于等于该年龄的对象就可以直接进去老年代，无需达到MaxTenuringThreshold。
```



> - 老年代 ： 三分之二的堆空间
> - 年轻代 ： 三分之一的堆空间
>
> eden区、s0区、s1区的大小一般为 $8:1:1$。

`新生代垃圾回收`

> 使用**标记-复制**算法。
>
> 大体流程：把eden区中不需要删除的对象复制到s0区，然后eden区与s1区对象删除；
>
> s1与s0循环使用，即：e+s1复制到s0；e+s0复制到s1;e+s1复制到s0; 如此往复。

`老年代垃圾回收`

> 老年代内存满了以后会进行垃圾回收(一般同时伴随着年轻代垃圾回收)，成为 Full GC，引起$Stop-The-World$。

> Java程序全局暂停，进行垃圾回收(native代码可以执行，但不能和JVM交互)。
>
> 垃圾回收算法：**标记-清除、标记-整理**。

![image-20210807152430735](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210807152430735.png)

**STW发生在垃圾回收的哪些阶段**

- 新生代GC： 都会发生STW——影响: 因为**MinorGC时间非常快，几乎忽略不计，影响很小；**
- 老年代GC︰ 根据阶段来看是否会STW——影响: **非常大。(老年代空间大，需要回收的对象多，耗时也多)；**
- FullGC： 一般指影响比较大的、暂停用户线程时间比较久的GC; **影响很大(STW)**，所以一般都包含Major GC。可能出现Minor GC

##### YoungGC和Full GC有什么不同

大多数情况下，对象在新生代中eden区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次MinorGC。

- 新生代GC（MinorGC/YoungGC）：指发生新生代的的垃圾收集动作，YoungGC非常频繁，回收速度一般也比较快。
- 老年代GC（MajorGC/FullGC）：指发生在老年代的GC，出现了FullGC经常会伴随至少一次的YoungGC（并非绝对），FullGC的速度一般会比YoungGC的慢10倍以上。

##### 强引用、软引用、弱引用、虚引用

- **强引用**
  - 使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，**垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出`OutOfMemoryError`错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。**
- **软引用**
  - 如果一个对象只具有软引用，那就类似于可有可无的生活用品。**如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。**只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
  - 软引用可以和一个引用队列 (`ReferenceQueue`) 联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。
- **弱引用**
  - 如果一个对象只具有弱引用，那就类似于可有可无的生活用品。**弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，*不管当前内存空间足够与否*，都会回收它的内存。**不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
  - 弱引用可以和一个引用队列(`ReferenceQueue`)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
- **虚引用**
  - “虚引用“顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。**如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。**
  - **虚引用主要用来跟踪对象被垃圾回收的活动。**
  - 虚引用与软引用和弱引用的一个区别在于：虚引用**必须和**引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

> 特别注意，在**程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

#### 回收方法区

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

##### 如何判断一个常量是废弃常量

**运行时常量池主要回收的是废弃的常量。**

假如在常量池中存在字符串"abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量"abc"就是废弃常量，如果这时发生内存回收的话而且有必要的话，“abc"就会被系统清理出常量池。

##### 如何判断一个类是无用的类

**方法区回收的是无用的类**

类需要同时满足下面三个条件才能算是“无用的类”：

- 该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例。
- 该类的 `ClassLoader` 已经被回收；
- 该类的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机**可以**对满足上述3个条件的无用类进行回收，这里说的**仅仅是可以，并不是像对象一样不使用了就必然会回收**。是否对类进行回收，HotSpot虚拟机提供了 `-Xnoclassgc` 参数进行控制，还可以使用 `-verbose：class` 以及` -XX：+TraceClassLoading`、`-XX： +TraceClassUnLoading` 查看类加载和卸载信息，其中 `-verbose：class` 和 `-XX： +TraceClassLoading` 可以在 Product 版的虚拟机中使用，`-XX：+TraceClassUnLoading` 参数需要 FastDebug 版的虚拟机支持。

***************

#### [JVM常用参数整理](https://www.cnblogs.com/cdfive2018/p/12320687.html)

JVM启动参数有三类：标准参数(-)、非标准参数(-X)、非Stable参数(-XX)。

- 标准参数(-）：所有的JVM实现都必须实现这些参数的功能，而且向后兼容。
- 非标准参数（-X）：默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足，且不保证向后兼容。
- 非Stable参数（-XX）：此类参数各个jvm实现会有所不同，将来可能会随时取消，需要慎重使用。

还有好多：https://blog.csdn.net/wang379275614/article/details/78471604。

- 内存相关	
  - `-Xms`：最小堆大小，如 `-Xms256m`
  - `-Xmx`：最大堆大小，如 `-Xmx512m`
  - `-Xmn`：新生代大小，如 `-Xmn是64m`
  - `-XX:NewRatio`：新生代与老年代的比例，如–XX:NewRatio=2，老年代过大的时候，Full GC的时间会很长；老年代过小，则很容易触发Full GC，Full GC频率过高。
  - `-XX:SurvivorRation`：设置Eden与Srivivor的大小比例，如-XX:SurvivorRation=8，代表1个Survivor是Eden的1/8，是整个新生代的1/10。
  - `-Xss`：每个线程堆栈大小，如-Xss1m，每个线程都有独立的栈空间，局部变量、参数分配在栈上
  - `-XX:PermSize`： 指JDK1.6定永久代最小内存值，如-XX:PermSize=64M
  - `-XX:MaxPermSize` : 指JDK1.6定永久代最大内存值，如-XX:MaxPermSize=512M
  - -`XX:MetaspaceSize` ：指JDK1.7及以后Metaspace扩容时触发FullGC的初始化阈值
  - `-XX:MaxMetaspaceSize`：指JDK1.7及以后Metaspace扩容时触发FullGC的最大阈值
- GC相关
  - `-verbose:gc`：记录GC运行以及运行时间，用于查看GC是否是应用的瓶颈
  - `-verbose:class`：输出jvm载入类的相关信息，用于诊断找不到类或者类冲突
  - `-XX:+PrintGCDetails`：打印GC详细信息
  - `-XX:-DisableExplicitGC`：禁止显式GC，即禁止程序中System.gc()
  - `-XX:-UseParallelGC`：启用并行GC
  - `-XX:+UseParNewGC`：新生代使用ParNew回收器，老年代使用串行回收器
  - `-XX:+UseConcMarkSweepGC`：新生代使用ParNew回收器，老年代使用CMS回收器
- 项目相关
  - `-XX:+HeapDumpOnOutOfMemoryError`：OOM时导出堆快照到文件
  - `-XX:+HeapDumpPath`，OOM时导出文件路径
  - `-XX:OnOutOfMemoryError`：OOM时操作，比如如执行脚本发送邮件
  - `-XX:+TraceClassLoading`：打印加载类的详细信息

************

#### JVM调优

https://zhuanlan.zhihu.com/p/58897189

#### ==垃圾收集算法(GC)==

##### ==如何判断对象是否死亡(如何判断对象是否是垃圾)==

堆**垃圾回收的第一步就是判断哪些对象已经死亡。**

1. 引用计数法：给对象添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。

   > 特点是实现简单，而且效率较高，但是它无法解决循环引用的问题，因此在Java中并没有采用这种方式（Python采用的是引用计数法）。
   >
   > 循环引用：当对象A持有对象B的引用，同时对象B也持有对象A的引用，这种情况下，对象A的引用数量为1，对象B的引用数量也为1，这两个对象循环依赖之后，形成了孤岛，出了这个孤岛，外部再无任何引用能找到它们，根据引用计数规则，它们不属于垃圾对象，从而无法被回收。

2. **可达性分析算法**：这个算法的基本思想就是通过一系列的称为 `GCRoots` 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 `GCRoots` 没有任何引用链相连的话，则证明此对象是不可用的。

   > 被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程：如果对象在进行可达性分析的时候发现没有与 `GC Roots` 相连接的引用链，那么它会被第一次标记并且进行一次筛选，**筛选的条件**是此对象是否有必要执行 `finalize()` 方法。
   >
   > - 当此对象没有覆盖  `finalize()` 方法，或者  `finalize()` 方法已经被虚拟机调用过，虚拟机会将这两种情况都视为 **没有必要执行。**
   > - 如果这个对象被判定为有必要执行  `finalize()` 方法，那么这个对象将会放置在一个叫做 `F-Queue` 的队列中，并在稍后由一个虚拟机自动建立的、优先级很低的 `Finalize` 线程去执行它。**这里的执行是指虚拟机会触发这个方法，但并不承诺等待他运行结束。**(如果一个对象在 `finalize()`方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致 `F-Queue` 队列中其他对象永久处于等待，甚至导致整个内存回收系统 崩溃)。
   >
   > `finalize()` 方法是对象逃脱死亡的最后一次机会，稍后 `GC` 将对 `F-Queue` 中的对象 进行第二次小规模的标记，如果对象要在`finalize()` 中成功拯救自己——只要重新与引用链 上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的 成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃 脱，那基本上它就真的被回收了。
   >
   > ```java
   > protected void finalize() throws Throwable {
   >     }
   > /**
   > finalize()是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，即当一个对象被虚拟机宣告死亡时会先调用finalize()方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）
   > 任何一个对象的 finalize() 方法只会被系统调用一次，如果对象面临下一次回收，他的 finalize() 方法不会被再次执行。
   > */
   > ```
   > 

![image-20210406145512981](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210406145512981.png)

###### GC Roots

- 虚拟机栈（帧栈中的本地变量表）中引用的对象。

  > ```java
  > public class Rumenz{
  >      public static  void main(String[] args) {
  >              Rumenz a = new Rumenz();
  >              a = null;
  >      }
  > }
  > a是栈帧中的本地变量,a就是GC Root,由于a=null,a与new Rumenz()对象断开了链接,所以对象会被回收。
  > ```

- 方法区中类静态属性引用的对象。

  > ```java
  > public class Rumenz{
  >      public static Rumenz r;
  >      public static void main(String[] args){
  >         Rumenz a=new Rumenz();
  >         a.r=new Rumenz();
  >         a=null;
  >      }
  > }
  > 栈帧中的本地变量a=null,由于a断开了与GC Root对象(a对象)的联系,所以a对象会被回收。由于给Rumenz的成员变量r赋值了变量的引用,并且r成员变量是静态的,所以r就是一个GC Root对象,所以r指向的对象不会被回收。
  > ```

- 方法区中常量引用的对象。

  > ```java
  > public class Rumenz{
  >      public static final Rumenz r=new Rumenz();
  >      public static void main(String[] args){
  >         Rumenz a=new Rumenz();
  >         a=null;
  >      }
  > }
  > 常量r引用的对象不会因为a引用的对象的回收而被回收
  > ```

- 本地方法栈中JNI（Native方法）引用的对象。

##### 标记-清除算法

> 标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象。
>
> 问题：
>
> 1. 效率问题：标记和清除两个过程的效率不高；
> 2. 空间问题：会产生大量不连续的空间碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。

<img src="https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210406153221847.png" alt="image-20210406153221847" style="zoom:50%;" />

##### 复制算法

为了解决效率问题，复制算法出现了。

**将内存分为大小相同的两块，每次使用其中一块。当这一块的内存使用完后，就将还存活的对象复制到另一块上去，然后再把使用的空间一次清理掉。**

![image-20210807151605254](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210807151605254.png)

**优点：**实现简单，运行高效并且不容易产生内存碎片。

**缺点：**内存空间浪费很严重，因为能够使用的内存缩减到原来的一半；另外，因内存中的存活对象经历了一次挪动，从内存A挪移到了内存B中，其内存地址必然发生变动，需要在挪动对象的同时修改该对象的所有引用指向的地址，当存活对象很多时，会很大程度降低该算法的效率。

**所以该算法，在存活对象比较少时，执行效率会比较高。**

##### 标记-整理算法

复制算法在对象存活率较高的时候就要进行较多的复制操作，效率会变低。

根据**老年代**的特点出的一种标记算法，标记过程与“标记-清理”算法一样，后续步骤是**让所有==存活的对象==向一端移动，然后直接清理掉边界以外的内存**。

![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/831d995973d560f517e2ba7eb42f1d2e.png)

**优点：**不会产生碎片化；内存大小不用人为缩减一半

**缺点：**需要挪动对象，也会涉及对象引用的调整。

##### 分代收集算法

​		当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是**根据对象存活周期的不同将内存分为几块**。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

​		比如在**新生代中，每次收集都会有大量对象死去，所以可以选择复制算法**，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而**老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法**进行垃圾收集。

##### HotSpot为什么要分为新生代和老年代

提升 GC 效率。

#### ==常见的垃圾回收器==

> 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。
>

使用 `java -XX:+PrintCommandLineFlags -version` 查看 JDK 使用的垃圾回收器

- JDK 1.8 

  - ```java
    C:\Users\Administrator>java -XX:+PrintCommandLineFlags -version
    -XX:InitialHeapSize=133159296 -XX:MaxHeapSize=2130548736 -XX:+PrintCommandLineFlags 
    -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC
    java version "1.8.0_201"
    Java(TM) SE Runtime Environment (build 1.8.0_201-b09)
    Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)
    ```

  - 默认是 **`Parallel scavenge + Parallel  Old`** 收集器组合。

- JDK 11以后

  - ```java
    C:\Users\LYJ>java -XX:+PrintCommandLineFlags -version
    -XX:ConcGCThreads=2 -XX:G1ConcRefinementThreads=8 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=264856128 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4237698048 -XX:MinHeapSize=6815736 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC -XX:-UseLargePagesIndividualAllocation
    java version "16.0.1" 2021-04-20
    Java(TM) SE Runtime Environment (build 16.0.1+9-24)
    Java HotSpot(TM) 64-Bit Server VM (build 16.0.1+9-24, mixed mode, sharing)
    ```

  - 默认是 **`G1`** 收集器

##### Serial 收集器

> 单线程收集器。
>
> 它只会使用一条垃圾收集器线程去完成垃圾回收工作，更重要的是它在进行垃圾回收工作的时候**必须暂停其他所有工作的线程**($Stop\ \  The\ \ World$)，直到它收集结束。
>
> <img src="https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210406155743440.png" alt="image-20210406155743440" style="zoom:100%;" />
>
> 优点：与其他收集器的单线程相比简单高效；没有线程交互的开销，所以单线程手机效率高。**对于运行在Client模式下的虚拟机来说是个不错的选择。**

##### ParNew 收集器

> ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。
>
> <img src="https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210406160250660.png" alt="image-20210406160250660" style="zoom:100%;" />
>
> **许多运行在Server模式下的虚拟机的首要选择。**除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器）配合工作。

**并发与并行**

- 并行：多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- 并发：用户线程与垃圾收集线程同时执行(不一定是并行，可能会交替执行)，用户程序仍在继续，而垃圾收集器运行在另一个CPU上。

##### Parallel Scavenge收集器

> 类似于 `ParNew` 收集器
>
> > ```bash
> > -XX:+UseParallelGC
> >     使用 Parallel 收集器+老年代
> > -XX:+UseParallelOldGC
> >     使用 Parallel 收集器+老年代并行
> > ```
>
> **`Parallel Scavenge` 收集器关注点是吞吐量（高效率的利用CPU）。`CMS` 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。**`Parallel Scavenge` 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。
>
> <img src="https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210406162543465.png" alt="image-20210406162543465" style="zoom:80%;" />

##### Serial Old收集器

> Serial收集器的老年代版本。它同样是一个单线程收集器。“标记-整理”算法。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。

##### Parallel Old收集器

> Parallel Scavenge收集器的老年代版本。使用多线程和“**标记-整理”**算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel Scavenge收集器和Parallel old收集器。

##### CMS 收集器

> CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。
>
> **CMS(Concurrent Mark Sweep)收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**。
>
> 使用**标记-清除**算法。**算法是基于老年代执行的。**
>
> 整个过程分为四个步骤：
>
> - **初始标记：**暂停所有的其他线程，并记录下直接与 `GC root` 相连的对象，速度很快；会发生$Stop\ \  The\ \ World$。
> - **并发标记：**同时开启 `GC` 线程和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
> - **重新标记：**重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。会发生$Stop\ \  The\ \ World$。
> - **并发清除：开启用户线程**，同时GC线程开始对已标记的区域做清扫。
>
> 整个过程中耗时最长的**并发标记和并发清除**过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

![image-20210406190959658](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210406190959658.png)

> 优点：并发收集、低停顿。
>
> 缺点：
>
> - 对CPU资源敏感；
> - 无法处理浮动垃圾。CMS并发清理阶段用户线程还在运行着，伴随着程序运行自然会产生新的垃圾。这一部分垃圾出现在标记过程之后，CMS无法在当此收集中处理掉他们，只好待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。
> - 使用的回收算法“标记-清除”算法会导致收集结束时会有大量空间碎片产生。
>   - 为了解决这个问题，CMS收集器提供了一个 `-XX:+UseCMSCompactAtFullCollection` 开关(默认是开启的)，用于在CMS收集器顶不住要进行Full GC的时候开启内存碎片的**合并整理过程**，**内存合并整理**的过程是无法并发的，空间碎片问题没有了，但停顿的时间不得不变长。
>   - 还有一个参数 `-XX:CMSFullGCBeforeCompaction`，这个参数是用于设置执行多少次不压缩的 Full GC 后，来一次压缩的(默认值为0，表示每次进入 Full GC 时都进行碎片整理)。

###### 错标与漏标

> **`CMS`收集器的问题**
>
> ```markdown
> **
> 1. 漏标   原本不是垃圾，但是GC的过程中，用户线程将其引用关系修改，导致GC Roots不可达，成为了垃圾。这种情况还好一点，无非就是产生了一些浮动垃圾，下次GC再清理就好了。
> 2. 错标   原本是垃圾，但是GC的过程中，用户线程将引用重新指向了它，这时如果GC一旦将其回收，将会导致程序运行错误。
> **
> ```
>
> **漏标**
>
> 假设 GC 已经在遍历对象B了，而此时用户线程执行了`A.B=null`的操作，切断了A到B的引用。
>
> ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/20201108150732916.png)
>
> 本来执行了`A.B=null`之后，B、D、E都可以被回收了，但是由于B已经变为灰色，它仍会被当做存活对象，继续遍历下去。
>
> 最终的结果就是本轮GC不会回收B、D、E，留到下次GC时回收，也算是浮动垃圾的一部分。
>
> 实际上，这个问题依然可以通过「写屏障」来解决，只要在A写B的时候加入写屏障，记录下B被切断的记录，重新标记时可以再把他们标为白色即可。
>
> **错标**
>
> 假设GC线程已经遍历到B了，此时用户线程执行了以下操作：
>
> ```java
> B.D=null;//B到D的引用被切断
> A.xx=D;//A到D的引用被建立
> ```
>
> ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/20201108155353123.png)
>
> B到D的引用被切断，且A到D的引用被建立。
> 此时GC线程继续工作，由于B不再引用D了，尽管A又引用了D，但是因为A已经标记为黑色，GC不会再遍历A了，所以D会被标记为白色，最后被当做垃圾回收。
> 可以看到错标的结果比漏表严重的多，浮动垃圾可以下次GC清理，而把不该回收的对象回收掉，将会造成程序运行错误。
>
> 错标只有在满足下面两种情况下才会发生：
>
> ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/20201108161333605.png)
>
> 只要打破任一条件，就可以解决错标的问题。
>
> ```markdown
> **
> 1. 原始快照打破的是第一个条件：当灰色对象指向白色对象的引用被断开时，就将这条引用关系记录下来。当扫描结束后，再以这些灰色对象为根，重新扫描一次。相当于无论引用关系是否删除，都会按照刚开始扫描时那一瞬间的对象图快照来扫描。
> 2. 增量更新打破的是第二个条件：当黑色指向白色的引用被建立时，就将这个新的引用关系记录下来，等扫描结束后，再以这些记录中的黑色对象为根，重新扫描一次。相当于黑色对象一旦建立了指向白色对象的引用，就会变为灰色对象。
> **
> # CMS采用的方案就是：写屏障+增量更新来实现的，打破的是第二个条件。
> **
> > 当黑色指向白色的引用被建立时，通过写屏障来记录引用关系，等扫描结束后，再以引用关系里的黑色对象为根重新扫描一次即可。
> ```
>
> 伪代码
>
> ```java
> class A{
> 	private D d;
> 
> 	public void setD(D d) {
> 		writeBarrier(d);// 插入一条写屏障
> 		this.d = d;
> 	}
> 
> 	private void writeBarrier(D d){
> 		// 将A -> D的引用关系记录下来，后续重新扫描
> 	}
> }
> 
> ```

###### 三色标记算法

**`CMS`** 将对象分成三种颜色：

```markdown
**
1. 黑色
	1.1 对象本身及其所有的引用都被扫描过
	1.2 黑色不能直接指向白色
	1.3 不能被回收
2. 灰色
	2.1 对象本身被扫描
	2.2 其引用至少还有一个没有被扫描
3. 白色
	3.1 没有被GC扫描
	3.2 扫描结束后白色的可以被回收
**
```

标记的过程大致如下：

```markdown
**
1. 刚开始，所有的对象都是白色，没有被访问。
2. 将GC Roots直接关联的对象置为灰色。
3. 遍历灰色对象的所有引用，灰色对象本身置为黑色，引用置为灰色。
4. 重复步骤3，直到没有灰色对象为止。
5. 结束时，黑色对象存活，白色对象回收。
**
# 这个过程正确执行的前提是没有其他线程改变对象间的引用关系，然而，并发标记的过程中，用户线程仍在运行，因此就会产生漏标和错标的情况。
```

##### G1收集器

> G1（Garbage-First）是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。
>
> G1垃圾回收器（`-XX:+UseG1GC`）不得不设置的一个参数：`-XX:MaxGCPauseMillis=10`，期望10毫秒内完成GC。
>
> ## G1的堆内存划分
>
> **G1将新生代，老年代的物理空间划分取消了**
>
> G1算法将堆划分为若干个区域（Region)，每个Region的大小可以通过参数`-XX:G1HeapRegionSize`设定，取值范围为1MB~32MB，且应为2的N次幂，它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。
>
> ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/825468-20190106234646269-1864284999.png)
>
> 在G1中，还有一种特殊的区域，叫Humongous区域。 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。
>
> 
>
> 具备以下特点：
>
> - 并行与并发：使用多个CPU(CPU或者CPU核心)来缩短 $Stop-The-World$ 停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。
> - 分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。
> - 空间整合：G1从整体来看是基于**“标记-整理”**算法实现的收集器；从局部上看是基于**“复制”**算法实现的。
> - 可预测的停顿：停顿时间是G1和CMS共同的关注点，但G1除了追求停顿外，还能建立**可预测的停顿时间模型**，能让使用者明确指定在一个长度为M毫秒的时间片段内。
>   - **G1收集器之所以能建立可预测的停顿时间模型，是因为G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。(这也是名字Garbage-First的由来)**
>
> **G1收集器的运作步骤：**
>
> ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/20200730161610159.png)
>
> - **初始标记**
>
>   - > 仅仅只是标记一下**GC Roots能直接关联到的对象**，并且修改TAMS(Next Top at Mark Start)指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。
>
> - **并发标记**
>
>   - > 从**GC Root开始对堆中对象进行可达性分析**，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可**与用户程序并发执行**。当对象图扫描完成以后，并发时有引用变动的对象会产生漏标问题，G1中会使用SATB(snapshot-at-the-beginning)算法来解决，后面会详细介绍。
>
> - **最终标记**
>
>   - > 对**用户线程做一个短暂的暂停**，用于处理并发标记阶段仍遗留下来的最后那少量的SATB记录(漏标对象)。
>
> - **筛选回收(清除)**
>
>   - > 负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的。
>     >
>     > **G1在清理垃圾时使用STW，所以可以采用 "标记整理" 算法。**
>
> **其他：**在G1收集器中，Region之间的对象引用以及其他收集器中的新生代和老年代之间的对象引用，虚拟机都是使用 `Remembered Set` 来避免全堆扫描的。G1中每个Region都有一个与之对应的`Remembered Set` ，虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 `Write Barrier` 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中，如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属 Region 的 `Remembered Set`之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 `Remembered Set` 即可保证不对全堆扫描也不会有遗漏。
>
> **G1收集器的适用场景**
>
> - 超过50%的Java堆被活动数据占用
> - 对象分配频率或年代提升频率变化很大
> - GC停顿时间过长(长于0.5至1秒) 
>   - **原因: **G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长。

##### CMS 和 G1 的区别

- **区别一： 使用范围不一样**

  - > CMS收集器是老年代的收集器，可以配合新生代的 `Serial` 和 `ParNew `收集器一起使用
    > G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用。

- **区别二：`Stop-The-World` 的时间**

  - > CMS收集器以最小的停顿时间为目标的收集器。
    >
    > G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型)

- **区别三： 垃圾碎片**

  - > CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片;
    >
    > G1收集器使用的是“**标记-整理”**算法，进行了空间整合，降低了内存空间碎片;
    >
    > G1从整体来看是基于**“标记整理”**算法实现的收集器；从局部上看是基于**“复制”**算法实现的。

- **区别四： 垃圾回收的过程不一样**

  - 四个步骤不一样

**********

#### 类文件结构

类文件由单个CLassFile结构组成

<img src="https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210406192359995.png" alt="image-20210406192359995" style="zoom:50%;" />

Class文件字节码结构组织示意图

![image-20210406192454071](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210406192454071.png)

1.魔数：确定这个文件是否为一个能被虚拟机接收的Class文件。
2.Class文件版本：Class文件的版本号，保证编译正常执行。
3.常量池：常量池主要存放两大常量：字面量和符号引用。
4.访问标志：标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口，是否为public 或者abstract 类型，如果是类的话是否声明为final等等。
5.当前类索引，父类索引：类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于Java 语言的单继承，所以父类索引只有一个，除了`java.lang.0bject`之外，所有的java类都有父类，因此除了`java.1ang.0bject`外，所有Java类的父类索引都不为0。
6.接口索引集合：接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按implents（如果这个类本身是接口的话则是extends）后的接口顺序从左到右排列在接口索引集合中。
7.字段表集合：描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。
8.方法表集合：类中的方法。
9.属性表集合：在Class文件，字段表，方法表中都可以携带自己的属性表集合。

#### ==类加载过程==

过程：加载$\rightarrow$连接$\rightarrow$初始化。连接过程又分为：验证$\rightarrow$准备$\rightarrow$解析。

<img src="https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210406192858120.png" alt="image-20210406192858120" style="zoom:67%;" />

##### 加载这一步完成的事情

> - 通过全类名**获取定义此类的二进制字节流**
>
> - 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
>
> - 在内存中生成一个代表该类的 `java.lang.Class` 对象，作为方法区这些数据的访问入口

**一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的`loadClass()`方法）。数组类型不通过类加载器创建，它由Java虚拟机直接创建。**

加载阶段和连接阶段的部分内容是交叉进行的，**加载阶段尚未结束，连接阶段就已经开始**了。

##### 连接

- 验证：确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。可以考虑使用 `-Xverify:none` 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

  - 文件格式验证：如是否以魔数 0xCAFEBABE 开头、主、次版本号是否在当前虚拟机处理范围之内、常量合理性验证等。
    此阶段保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java类型信息的要求。
  - 元数据验证：是否存在父类，父类的继承链是否正确，抽象类是否实现了其父类或接口之中要求实现的所有方法，字段、方法是否与父类产生矛盾等。
    第二阶段，保证不存在不符合 Java 语言规范的元数据信息。
  - 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。例如保证跳转指令不会跳转到方法体以外的字节码指令上。
  - 符号引用验证：在解析阶段中发生，保证可以将符号引用转化为直接引用。
- 准备：为类的**静态变量**分配内存，并将其初始化为默认值。
- 解析：虚拟机将常量池内的符号引用替换为直接引用的过程。
  - 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。

##### 初始化

为类的静态变量赋予正确的初始值。

执行 `<clinit>()` 方法的过程。

- `<clinit>()` 方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有**变量**的赋值动作和静态代码块中的语句合并产生的。（不包括构造器中的语句。构造器是初始化对象的，类加载完成后，创建对象时候将调用的 `<init>()` 方法来初始化对象）。

  静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。例如：

  > ```java
  > public class Test {
  >     static {
  >         // 给变量赋值可以正常编译通过
  >         i = 0;
  >         // 这句编译器会提示"非法向前引用"
  >         System.out.println(i);
  >     }
  >     static int i = 1;
  > }
  > ```

- 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。

  虚拟机会保证在子类的 `<clinit>()` 方法执行之前，父类的 `<clinit>()` 方法已经执行完毕，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。

- `<clinit>()` 方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 `<clinit>()` 方法。

- 虚拟机会保证一个类的 `<clinit>()` 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 `<clinit>()` 方法，其他线程都需要阻塞等待，直到活动线程执行 `<clinit>()` 方法完毕。

###### ==**例子**==

> ```java
> package Leran;
> 
> /**
>  * @author LYJ
>  * @create 2021-06-09 21:05
>  */
> public class TestClassDemo {
>     public static void main(String[] args) {
>         System.out.println(Son.factor);
>     }
> }
> class Grandpa {
>     static {
>         System.out.println("Grandpa in static");
>     }
> }
> 
> class Father extends Grandpa{
>     static {
>         System.out.println("father in static");
>     }
>     public static int factor = 25;
>     public Father(){
>         System.out.println("I am father");
>     }
> }
> 
> class Son extends Father{
>     static {
>         System.out.println("son in static");
>     }
>     public Son(){
>         System.out.println("I am son");
>     }
> }
> 
> 运行结果：
> Grandpa in static
> father in static
> 25
> ```
>
> 所以在类中，加载顺序为：
>
> 1.首先加载父类的静态字段或者静态语句块
>
> 2.子类的静态字段或静态语句块
>
> 3.父类普通变量以及语句块
>
> 4.父类构造方法被加载
>
> 5.子类变量或者语句块被加载
>
> 6.子类构造方法被加载
>
> **==当class文件被加载进内存，开始初始化的时候，被static修饰的变量或者方法即被分配了内存，而其他变量是在对象被创建后，才被分配了内存的。==**
>
> > ```java
> > package Leran;
> > 
> > /**
> >  * @author LYJ
> >  * @create 2021-06-10 19:39
> >  */
> > public class Test {
> >     public static void main(String[] args) {
> >         new Test();                         //4.第四步，new一个类，但在new之前要处理匿名代码块
> >     }
> >     static int num = 4;                    //2.第二步，静态变量和静态代码块的加载顺序由编写先后决定
> >     {
> >         num += 3;
> >         System.out.println("b");           //5.第五步，按照顺序加载匿名代码块，代码块中有打印
> >     }
> >     int a = 5;                             //6.第六步，按照顺序加载变量
> >     { // 成员变量第三个
> >         System.out.println("c");           //7.第七步，按照顺序打印c
> >     }
> >     Test() { // 类的构造函数，第四个加载
> >         System.out.println("d");           //8.第八步，最后加载构造函数，完成对象的建立
> >     }
> >     static {                              // 3.第三步，静态块，然后执行静态代码块，因为有输出，故打印a
> >         System.out.println("a");
> >     }
> >     static void run()                    // 静态方法，调用的时候才加载// 注意看，e没有加载
> >     {
> >         System.out.println("e");
> >     }
> > }
> > a
> > b
> > c
> > d
> > ```
> >
> > **==静态方法，调用的时候才加载==**

###### 类什么时候才被初始化

**类的主动引用（一定会发生类的初始化）**

> - 当虚拟机启动，先初始化main方法所在的类
> - new一个类的对象
> - 调用类的静态成员(除了final常量)和静态方法
> - 反射(`Class.forName("路径.Dog")`)
> - 初始化一个类的子类，如果其父类没有被初始化，会首先初始化子类的父类。
> - JVM启动时标明的启动类，即文件名和类名相同的那个类。

以上场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用，例如：

> 1. 通过子类引用父类的静态字段，不会导致子类初始化。
> 2. 通过数组定义来引用类，不会触发此类的初始化。`MyClass[] cs = new MyClass[10];`
> 3. 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

##### 类加载器

> 负责读取 Java 字节代码，并转换成`java.lang.Class`类的一个实例；

Java是运行在Java的虚拟机(JVM)中的，但是它是如何运行在JVM中了呢？我们在IDE中编写的Java源代码被编译器编译成.class的字节码文件。然后由我们得ClassLoader负责将这些class文件给加载到JVM中去执行。  

JVM中内置了三个重要的`ClassLoader`，除了`BootstrapClassLoader`，其他类加载器均由Java实现且全部继承自`java.lang.ClassLoader`：

1. BootstrapClassLoader（启动类加载器）：最顶层的加载类，由C++实现，负责加载`%JAVA_HOME%/1ib `目录下的jar包和类或者或被`-Xbootclasspath`参数指定的路径中的所有类。
2. ExtensionClassLoader（扩展类加载器）：主要负责加载目录`%JRE_HOME%/1ib/ext`目录下的jar包和类，或被java.ext.dirs系统变量所指定的路径下的jar包。
3. AppClassLoader（应用程序类加载器）：面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。

##### ==双亲委派模型==

每一个类都有一个对应它的类加载器。系统中的`ClassLoder()`在协同工作的时候会默认使用双亲委派模型。即**在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的类加载器处理，父类中同理也会先检查自己是否已经加载过，如果没有加载过再往上。直到到达Bootstrap类加载器之前，都是在检查是否加载过，并不会选择自己去加载。因此所有的请求最终都应该传送到顶层的启动类加载器(BootstrapClassLoader)中。直到Bootstrap类加载器，已经没有父加载器了，这时候开始考虑自己是否能加载了。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 BootstrapClassLoader作为父类加载器。如果没有任何加载器能加载，就会抛出ClassNotFoundException。**

![image-20210406193755049](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210406193755049.png)

###### 双亲委派模型的好处、作用

双亲委派模型保证了Java程序的==稳定运行==，可以==避免类的重复加载==（JVM区分不同类的方式不仅仅根据类名，**相同的类文件被不同的类加载器加载产生的是两个不同的类**），也保证了Java的核心API不被篡改。如果不用没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现多个不同的0bject类。

- ==自己建立一个 `java.lang.String` 类，在另外的程序中加载 String 类的时候，加载的还是JDK 自带的 String 类。==
  - 由于我们定义的String类本应用系统类加载器，但它并不会自己先加载，而是把这个请求委托给父类的加载器去执行，到了扩展类加载器发现String类不归自己管，再委托给父类加载器（引导类加载器），这时发现是java.lang包，这事就归引导类加载器管，所以加载的是 JDK 自带的 String 类。**所以，用户自定义的java.lang.String不被加载，也就是不会被使用。**
- ==在 java.lang 包下定义一个 ShkStart 类 (自定义类名)，出于保护机制，java.lang 包下不允许我们自定义类。==

###### 如果我们不想用双亲委派模型怎么办？

为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重载 `loadClass()` 即可。

###### 如何自定义类加载器？

1. 继承  `java.lang.ClassLoader`

   除了 `BootstrapClassLoader`，其他类加载器均由Java实现且全部继承自`java.lang.ClassLoader`。如果我们要自定义自己的类加载器，很明显需要继承`ClassLoader`。

2. 重写父类的 `findClass()` 方法

   JDK 的 `loadCalss()` 方法在所有父类加载器无法加载的时候，会调用本身的 `findClass()` 方法来进行类加载，因此我们只需重写 `findClass()` 方法找到类的二进制数据即可。

##### JVM的类加载方式

类加载有三种方式：

- 命令行启动应用时候由JVM初始化加载
- 通过`Class.forName()`方法动态加载
- 通过`ClassLoader.loadClass()`方法动态加载

**Class.forName()和ClassLoader.loadClass()区别**

- `Class.forName()`：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；
- `ClassLoader.loadClass()`：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。
- `Class.forName(name,initialize,loader)`带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。

#### Java内存泄漏分析和解决

**内存泄漏**：对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用。

![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/2827798-583e7d9d5047a49c.gif)

需要先了解一下对象在内存中的状态。下面的这张图就解释了什么是**无用对象**以及什么是**未被引用对象**。

![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/2827798-eac74f6058065a09.jpeg)

上面图中可以看出，里面有被**引用对象**和**未被引用对象**。未被引用对象会被垃圾回收器回收，而被引用的对象却不会。未被引用的对象当然是不再被使用的对象，因为没有对象再引用它。然而**无用对象却不全是未被引用对象。其中还有被引用的。就是这种情况导致了内存泄漏。**

##### Java内存泄漏引起的原因

​		无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你 `Out of memory`。

长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是**因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景**。

​		比如说：A对象引用B对象，A对象的生命周期（t1-t4）比B对象的生命周期（t2-t3）长的多。当B对象没有被应用程序使用之后，A对象仍然在引用着B对象。这样，垃圾回收器就没办法将B对象从内存中移除，从而导致内存问题，因为如果A引用更多这样的对象，那将有更多的未被引用对象存在，并消耗内存空间。

> **具体的几大类**

- #### 静态集合类引起内存泄漏

  - 像 `HashMap`、`Vector` 等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象 `Object` 也不能被释放，因为他们也将一直被引用着。

- #### 监听器

  - 在 **java** 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如**addXXXListener()** 等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。

- #### 各种连接

  - 比如说数据库连接，如果忘记调用 `close()` 方法关闭连接的话，是不会被 **GC** 回收的。
  - 对于**Resultset** 和**Statement** 对象可以不进行显式回收，但**Connection** 一定要显式回收，因为**Connection** 在任何时候都无法自动回收，而**Connection**一旦回收，**Resultset** 和**Statement** 对象就会立即为**NULL**。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭**Resultset、Statement** 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的**Statement** 对象无法释放，从而引起内存泄漏。这种情况下一般都会在**try** 里面去的连接，在**finally**里面释放连接。

- ####  内部类和外部模块的引用

  - 内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。
  - 小心外部模块不经意的引用，例如程序员 A 负责 A 模块，调用了 B 模块的一个方法。这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B是否提供相应的操作去除引用。

- #### 单例模式

  - 单例对象在初始化后将在 **JVM** 的整个生命周期中存在（**以静态变量的方式**），如果单例对象持有外部的引用，那么这个对象将不能被 **JVM** 正常回收，导致内存泄漏。

#### JAVA内存泄漏和内存溢出的区别和联系

##### **内存泄漏 memory leak** 

> 是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。

##### **内存溢出 memory overflow**

> 指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错 **`OOM`** ,即所谓的内存溢出。

##### **二者的关系**

> - 内存泄漏的堆积最终会导致内存溢出;
> - 内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。;
> - 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。
> - 内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错。

#### 内存溢出的原因及解决方法

##### 内存溢出原因

1. 内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
2. 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
3. 代码中存在死循环或循环产生过多重复的对象实体；
4. 使用的第三方软件中的BUG；
5. 启动参数内存值设定的过小

##### 内存溢出的解决方案

第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)

第二步，检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。

第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。
重点排查以下几点：
1.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。

2.检查代码中是否有死循环或递归调用。

3.检查是否有大循环重复产生新对象实体。

4.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。

5.检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。

第四步，使用内存查看工具动态查看内存使用情况。



##### Java堆溢出

​	Java堆用于存储对象实例，只要不断地创建对象，并且保证 `GC Roots` 到对象之间有可达的路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。

堆的最小值 `-Xms` ，堆的最大值 `-Xmx`。

`-XX: +HeapDumpOnOutOfMemoryError` 可以让虚拟机在出现内存溢出时Dump出当前的内存堆转储快照以便事后分析。

![image-20210811074042770](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210811074042770.png)

​	Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出的时候，异常堆栈信息 `java.lang.OutOfMemoryError` 会跟着进一步提示 `Java heap space`。



##### 虚拟机栈和本地方法栈溢出

由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽 然 `-Xoss` 参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由 `-Xss` 参数设定。 

关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：

- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 `StackOverflowError` 异常。 

- 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 `OutOfMemoryError` 异常。

测试两种异常：

- 使用 `-Xss` 参数减少栈内存容量。结果：抛出 `StackOverflowError` 异常，异常出现时输出的堆栈深度相应缩小。
- 定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出 `StackOverflowError` 异常时输出的堆栈深度相应缩小。
- 多线程下，通过不断建立线程的方式可以产生内存溢出 `java.lang.OutOfMemoryError` 异常。但是这样产生的内存溢出异常与栈空间是否存够大并不存在任何联系。因为这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。



出现 `StackOverflowError` 异常时有错误堆栈可以阅读，相对来说比较容易找到问题的所在。但是，如果是多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，只能通过减少最大堆和减少栈容量来获取更多的线程。



##### 方法区和运行时常量池溢出

**运行时常量池：**

`String.intern()` 是一个 `Native` 方法，作用是：如果字符串常量池中已经包含一个等于此 String 对象的字符串，则返回常量池中这个字符串的 String 对象；否则，将此 String 对象包含的字符串添加到常量池中，并且返回此 String 对象的引用。

在JDK 1.6及之前的版本中，由于常量池分配在永久代内，我们可以通过 `-XX：PermSize` 和 `-XX：MaxPermSize` 限制方法区的大小，从而间接限制其中常量池的容量。

![image-20210811091953801](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210811091953801.png)

从运行结果中可以看到，运行时常量池溢出，在 `OutOfMemoryError` 后面跟随的提示信息 是 `“PermGen space”` ，说明运行时常量池属于方法区（HotSpot虚拟机中的永久代）的一部 分。



**方法区：**

要是想造成方法区异常，那么最好的办法就是产生大量的类。

我们不可能去手动写太多的类，只能使用动态生成，当然你也可以复制粘贴许多的 `jsp` , `jsp` 运行时会编译成class。但是最好的办法还是动态生成，了解spring的都知道，spring对类的增强使用的是 `CGLib` ，所谓的动态代理,所以今天使用 `CGLib` 。

![image-20210811094420009](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210811094420009.png)

方法区溢出是一种很常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。



##### 本机直接内存溢出

​    `DirectMemory` 容量可通过 `-XX：MaxDirectMemorySize` 指定，如果不指定，则默认与Java 堆最大值（`-Xmx`指定）一样，代码清单2-9越过了DirectByteBuffer类，直接通过反射获取 Unsafe实例进行内存分配（Unsafe类的getUnsafe（）方法限制了只有引导类加载器才会返回 实例，也就是设计者希望只有rt.jar中的类才能使用Unsafe的功能）。因为，虽然使用 DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申 请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方 法是unsafe.allocateMemory（）。

![image-20210811094912162](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210811094912162.png)



由 `DirectMemory `导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显 的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就 可以考虑检查一下是不是这方面的原因。



#### Java内存溢出、内存泄露的检测工具、检测命令

**工具类**

- `jps`       `JVM Process Status Tool`, 显示指定系统内所有的 `HotSpot` 虚拟进程

  - 可以列出正在运行的虚拟机进程，并显示虚拟机执行主类(Main Class, main()函数所在的类)的名称, 以及这些进程的本地虚拟机的唯一ID。

  - `jps` 可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，hostid为RMI注册表中注册的主机名。默认端口为1099。(前提是远程服务器提供jstatd服务)

  - ```bash
    jps命令格式：jps [-q] [-mlvV] [<hostid>]  
    -q  只输出LVMID，省略主类的名称
    -m  输出虚拟机京城启动时传递给主类main()函数的参数
    -l  输出主类的全名，如果京城执行的是Jar包，输出Jar路径
    -v  输出虚拟机进程启动时JVM参数
    ```

- `jstat`	`JVM Statistcs Monitoring Tool`，用于手机 `HotSpot` 虚拟机各方面的运行数据

  - 用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。

  - ```bash
    jstat命令行格式为：
    jstat [ options vmid [interval [s|ms] [count ] ] ] jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]
    jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]] 对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID是一致的，如果是远程虚拟机进程，那VMID的格式应当是：
    [protocl:] [//]lvmid[@hostname[:port]/servername]
    
    options：          
    -class                     监视类装载、卸载数量、总空间及类装载耗费的时间
    -gc                        监视java堆状况，包括Eden区、2个survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息
    -gccapacity                监视内容与-gc基本相同，但输出主要关注java堆各个区域使用到的最大和最小空间
    -gcutil                    监视内容与-gc基本内容，但输出主要关注已使用空间占总空间的百分比
    -gccause                   与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因
    -gcnew                     监视新生代GC的状况
    -gcnewcapacity             监视内容与-gcnew 基本相同，输出主要关注使用到的最大和最小空间
    -gcold                     监视老年代GC的状况
    -gcoldcapacity             监视内容与-gcold基本相同，输出主要关注使用到的最大和最小空间
    -gcpermcapaciyt            输出永久带使用到的最大和最小空间
    -complier                  输出JIT编译器编译过的方法、耗时等信息
    -printcompilation          输出已被JIT编译的方法
    ```

- `jinf`     `Configuration Info for java`，实时查看和调整虚拟机各项参数信息

  - 用于实时查看和调整虚拟机各项参数。使用 `jps` 命令的 `-v` 参数可以查看虚拟机启动时显示指定的参数列表，但如果想知道未被显式指定的参数，就只能利用 `jinfo` 的 `-flag` 选项进行查询了。

    当然JDK1.6或以上版本的话，使用 `java -XX:+PrintFlagsFinal` 查看参数默认值也是极好的。

  - ```bash
    jinfo命令格式：
    jinfo [option] <pid>
     
    where <option> is one of:
    -flag <name>         to print the value of the named VM flag
    -flag [+|-]<name>    to enable or disable the named VM flag
    -flag <name>=<value> to set the named VM flag to the given value
    ```

- `jmap`     `Memory Map for Java`，生成转储快照（一般称为headdump或dump文件）

  - ```bash
    用于生成堆转储快照。
    如果不适用jmap命令，想要获取Java堆转储快照还有一些比较“暴力”的手段，譬如：
    -XX:+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件
    -XX:+HeapDumpOnCtrlBreak参数则可使用[Ctrl]+[Break]键让虚拟机生成dump文件
    当然如果在linux系统下通过kill -3命令发送进程退出信号“恐吓”一下虚拟机，也能拿到dump文件
     
    jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列，java堆和永久代的详细信息，如空间使用率、当前用的是哪种GC收集器等。
     
    jmap命令格式：
    jmap [option] <pid>
     
    options：           
    -dump                生成java堆转储快照
    -finalizerinfo       显示在F-Queue中等待Finalizer线程执行finalize方法的对象
    -heap                显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等
    -histo               显示堆中对象统计信息，包括类、实例数量和合计容量
    -permstat            以ClassLoader为统计口径显示永久代内存状态
    -F                   当虚拟机进程对-dump选项没有响应时，可使用这个选项生成dump快照
    ```

- `jhat`     `JVM Heap Analysis Too`l，与jmap搭配使用，分析jmap生成的转储快照

  - ```bash
    与jmap搭配使用，分析jmap生成的堆转储快照。jhat内置了一个微型http/html服务器，生成dump文件的分析结果，可以在浏览器中查看。
    jhat的功能并不是很强大，并且在服务器上直接分析dump文件过分的消耗了硬件资源。在此推荐利用VisualVM、Eclipse Memory Analyzer、IBM HeapAnalyzer等工具。
     
    jhat 命令格式：
    jhat [-stack <bool>] [-refs <bool>] [-port <port>] [-baseline <file>] [-debug <int>] [-version] [-h|-help] <file>
    ```

- `jstack`   `Stack Trace for Java`，生成虚拟机当前时刻的线程快照（一般称为threddump或javacore文件）

  - ```bash
    用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈计划。
    生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。
     
    jstack命令格式：
    jstack [option]<pid>
     
    options:
    -F                    当正常输出的请求不被响应时，强制输出线程堆栈
    -l                      打印除堆栈以外关于锁的附加信息
    -m                    如果调用到本地方法的话，可以显示C/C++的堆栈
    ```







 
