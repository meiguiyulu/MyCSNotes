# 分布式相关

## 1、概念等基础知识

### 1.1 集群、分布式、SOA、微服务的概念及区别

**集群**：==不同服务器部署同一套应用服务对外提供访问==，实现服务的负载均衡或者互备(热备，主从等)，指同一种组件的多个实例，形成的逻辑上的整体。==单个节点可以提供完整服务。集群是物理形态==

**分布式：**==服务的不同模块部署在不同的服务器上，单个节点不能提供完整服务，需要多节点协调提供服务==(也可以是相同组件部署在不同节点、但节点间通过交换信息协作提供服务)，==分布式强调的是工作方式==

**SOA：**面向服务的架构，一种设计方法，其中包含多个服务， 服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在于操作系统进程中。各个服务之间通过网络调用。

- 中心化实现：ESB(企业服务总线)，各服务通过ESB进行交互，解决异构系统之间的连通性，通过协议转换、消息解析、消息路由把服务提供者的数据传
  送到服务消费者。很重，有一定的逻辑，可以解决一些公用逻辑的问题。
- 去中心化实现：微服务

**微服务：**在 SOA 上做的升华，微服务架构强调的一个重点是业务需要彻底的组件化和服务化，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成
服务单一职责
轻量级通信：去掉ESB总线，采用restapi通信

## 2、海量数据和高并发解决方案

### 2.1、海量数据的解决方案

1. **使用缓存**

   使用缓存框架的时候，==我们需要关心的就是什么时候创建缓存和缓存失效策略。==
   缓存的创建可以通过很多的方式进行创建，具体也需要根据自己的业务进行选择。例如，新闻首页的新闻应该在第一次读取数据的时候就进行缓存；对
   于点击率比较高的文章，可以将其文章内容进行缓存等。
   内存资源有限，选择如何创建缓存是一个值得思考的问题。另外，对于缓存的失效机制也是需要好好研究的，可以通过设置失效时间的方式进行设置；
   也可以通过对热门数据设置优先级，根据不同的优先级设置不同的失效时间等；
   需要注意的是，当我们删除一条数据的时候，我们要考虑到删除该条缓存，还要考虑在删除该条缓存之前该条数据是否已经到达缓存失效时间等各种情况！
   使用缓存的时候还要考虑到缓存服务器发生故障时候如何进行容错处理，是使用N多台服务器缓存相同的数据，通过分布式部署的方式对缓存数据进行控制，当一台发生故障的时候自动切换到其他的机器上去；还是通过Hash一致性的方式，等待缓存服务器恢复正常使用的时候重新指定到该缓存服务
   器。Hash一致性的另一个作用就是在分布式缓存服务器下对数据进行定位，将数据分布在不用缓存服务器上。

2. **使用页面静态技术**

   将这些静态的HTML、CSS、JS、图片资源等放置在缓存服务器上或者CDN服务器上，一般使用最多的应该是CDN服务器或者Nginx服务器提供的静态
   资源功能。

3. **数据库优化**

   数据库优化的方式很多，常见的可以分为：数据库表结构优化、SQL语句优化、分区、分表、索引优化、使用存储过程代替直接操作等 。

4. **分离数据库中活跃的数据**

   正如“二八定律”一样（80%的业务访问集中在20%的数据上），网站的数据虽然很多，但是经常被访问的数据还是有限的，因此可以讲这些相对活跃的
   数据进行分离出来单独进行保存来提高处理效率。
   其实前边使用缓存的思想就是一个很明显的分离数据库中活跃的数据的使用案例，将热门数据缓存在内存中。
   还有一种场景就是，例如一个网站的所用注册用户量很大千万级别，但是经常登录的用户只有百万级别，剩下的基本都是很长时间都没有进行登录操
   作，如果不把这些“僵尸用户”单独分离出去，那么我们每次查询其他登录用户的时候，就白白浪费了这些僵尸用户的查询操作。

5. **批量读取和延迟修改**

   ==批量读取和延迟修改的原理是通过减少操作数据库的操作来提高效率。==
   ==批量读取是将多次查询合并到一次中进行读取==，因为每一个数据库的请求操
   作都需要链接的建立和链接的释放，还是占用一部分资源的，批量读取可以
   通过异步的方式进行读取。
   ==延迟修改是对于一些高并发的并且修改频繁修改的数据，在每次修改的时候首先将数据保存到缓存中，然后定时将缓存中的数据保存到数据库中，程序可以在读取数据时可以同时读取数据库中和缓存中的数据。==
   例如：我现在在编写这份博客，我一开始写了一写内容然后点击发布了，再次回到Markdown进行修改操作，我有一个习惯，没写一些东西总是按一下
   上边的 “保存”按钮，然后我在另一个页面打开这篇博客查看，我的修改已经被更新，但是我还在 编辑！

6. **读写分离**

   读写分离的实质是将应用程序对数据库的读写操作分配到多个数据库服务器上，从而降低单台数据库的访问压力。
   读写分离一般通过配置主从数据库的方式，数据的读取来自从库，对数据库增加修改删除操作主库。

7. **使用NoSQL和Hadoop等技术**

   NoSQL是一种非结构化的非关系型数据库，由于其灵活性，突破了关系型数据库的条条框框，可以灵活的进行操作，另外，因为NoSQL通过多个块存储数据的特点，其操作大数据的速度也是

8. **分布式部署数据库**

   任何强大的单一服务器都满足不了大型网站持续增长的业务需求。数据库通过读写分离之后将一台数据库服务器拆分为两台或者多台数据库服务器，但
   是仍然满足不了持续增长的业务需求。分布式部署数据库是将网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。
   分布式部署数据库是一种很理想的情况，分布式数据库是将表存放在不同的数据库中然后再放到不同的数据库中，这样在处理请求的时候，如果需要调
   用多个表，则可以让多台服务器同时处理，从而提高处理效率。

   ![image-20210914223928873](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210914223928873.png)

9. **应用服务和数据服务分离**

   应用服务器和数据库服务器进行分离的目的是为了根据应用服务器的特点和数据库服务器的特点进行底层的优化，这样的话能够更好的发挥每一台服务
   器的特性，数据库服务器当然是有一定的磁盘空间，而应用服务器相对不需要太大的磁盘空间，这样的话进行分离是有好处的，也能防止一台服务器出现问题连带的其他服务也不可以使用。

   ![image-20210914224134560](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210914224134560.png)

10. **使用搜索引擎搜索数据库中的数据**

11. **进行业务的拆分**

    为什么进行业务的拆分，归根结底上还是使用的还是将不同的业务数据表部署到不用的服务器上，分别查找对应的数据以满足网站的需求。各个应用之
    间用过指定的URL连接获取不同的服务，
    例如一个大型的购物网站就会将首页、商铺、订单、买家、卖家等拆分为不同的子业务，一方面将业务模块分归为不同的团队进行开发，另外一方面不同的业务使用的数据库表部署到不同的服务器上，体现到拆分的思想，当一个业务模块使用的数据库服务器发生故障也不会影响其他业务模块的数据库正常使用。另外，当其中一个模块的访问量激增的时候还可以动态的扩展这个模块使用到的数据库的数量从而满足业务的需求。

### 2.2、高并发情况下的解决方案：

1. **应用程序和静态资源文件进行分离**

   所谓的静态资源就是我们网站中用到的Html、Css、Js、Image、Video、Gif等静态资源。应用程序和静态资源文件进行分离也是常见的前后端分离
   的解决方案，应用服务只提供相应的数据服务，静态资源部署在指定的服务器上（Nginx服务器或者是CDN服务器上），前端界面通过Angular JS或者Node JS提供的路由技术访问应用服务器的具体服务获取相应的数据在前端游览器上进行渲染。这样可以在很大程度上减轻后端服务器的压力。
   例如，百度主页使用的图片就是单独的一个域名服务器上进行部署的

2. **页面缓存**

   页面缓存是将应用生成的很少发生数据变化的页面缓存起来，这样就不需要每次都重新生成页面了，从而节省大量CPU资源，如果将缓存的页面放到内
   存中速度就更快。
   可以使用Nginx提供的缓存功能，或者可以使用专门的页面缓存服务器Squid。

3. **集群与分布式**

4. **反向代理**

5. **CDN**

   CDN服务器其实是一种集群页面缓存服务器，其目的就是尽早的返回用户所需要的数据，一方面加速用户访问速度，另一方面也减轻后端服务器的负载
   压力。
   CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。
   CDN通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载
   状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网
   络拥挤的状况，提高用户访问网站的响应速度。
   也就是说CDN服务器是部署在网络运行商的机房，提供的离用户最近的一层数据访问服务，用户在请求网站服务的时候，可以从距离用户最近的网络提供商机房获取数据。电信的用户会分配电信的节点，联通的会分配联通的节点。
   CDN分配请求的方式是特殊的，不是普通的负载均衡服务器来分配的那种，而是用专门的CDN域名解析服务器在解析与名的时候就分配好的。

   CDN结构图如下所示：

   ![image-20210914224852949](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210914224852949.png)

### 2.3、总结

本质很简单，一个是慢，一个是等。

两者是相互关联的，因为慢，所以要等，因为等，所以慢，解决了慢，也就解决了等，解决了等，也就解决了慢。
关键是如何解决慢和等，核心一个是短，一个是少，一个是**分流**,最后一个是**集群/横向扩张/读写分离/建立主从**。

#### 短是指路径要短

典型的mvc结构是请求->controller->model->dao->view，然后把页面返回给用
户。要想短的话，
1，**页面静态化**- -----用户可以直接获取页面，不用走那么多流程，比较适用于页面不频繁更新。
2，**使用缓存**------ 第一次获取数据从数据库准提取，然后保存在缓存中，以后就可以直接从缓存提取数据。不过需要有机制维持缓存和数据库的一致性。
3，**使用储存过程**------那些处理一次请求需要多次访问数据库的操作，可以把操作整合到储存过程，这样只要一次数据库访问就可以了。
4，**批量读取** ------- 高并发情况下，可以把多个请求的查询合并到一次进行，以减少数据库的访问次数

5，**延迟修改** ------ 高并发情况下，可以把多次修改请求，先保存在缓存中，然后定时将缓存中的数据保存到数据库中，风险是可能会断电丢失缓存中的数
据，
6, **使用索引** ------ 索引可以看作是特殊的缓存，尽量使用索引就要求where字句中精确的给出索引列的值

#### 少是指查询的数据要少

1、**分表**-------把本来同一张表的内容，可以按照地区，类别等分成多张表，很简单的一个思路，但是要尽量避免分出来的多表关联查询。
2、**分离活跃数据**----------例如登录用户业务，注册用户很多，但是活跃的登录用户很少，可以把活跃用户专门保存一张表，查询是先查询活跃表，没有的话再查总表，这也类似与缓存啦。
3、**分块**-----------数据库层面的优化，对程序是透明的，查询大数据只用找到相应块就行。

#### 分流

1、**集群**-----将并发请求分配到不同的服务器上，可以是业务服务器，也可以是数据库服务器。

2、**分布式**-----分布式是把单次请求的多项业务逻辑分配到多个服务器上，这样可以同步处理很多逻辑，一般使用与特别复杂的业务请求。（也要实现集群也就是读写分离）

3、**CDN**----在域名解析层面的分流，例如将华南地区的用户请求分配到华南的服务器，华中地区的用户请求分配到华中的服务器。

**横向扩展**

## 3、哈希一致性

参考链接：[5分钟理解一致性哈希算法 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903750860013576)

### 3.1 、分布式缓存

随着业务的扩展，流量的剧增，单体项目逐渐划分为分布式系统。对于经常使用的数据，我们可以使用Redis作为缓存机制，减少数据层的压力。因此，重构后的系统架构如下图所示：

![image-20210914225519327](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210914225519327.png)

优化最简单的策略就是，把常用的数据保存到Redis中，为了实现高可用使用了3台Redis（没有设置集群，集群至少要6台）。每次Redis请求会随机发送到其中一台，但是这种策略会引发如下两个问题：

- 同一份数据可能在多个Redis数据库，造成数据冗余
- 某一份数据在其中一台Redis数据库已存在，但是再次访问Redis数据库，并没有命中数据已存在的库。无法保证对相同的key的所有访问都发送到相同的Redis中

要解决上述的问题，我们需要稍稍改变一些key存入Redis的规则：使用hash算法 例如，有三台Redis，对于每次的访问都可以通过计算hash来求得hash值。
如公式 h=hash(key)%3，我们把Redis编号设置成0,1,2来保存对应hash计算出来的值，h的值等于Redis对应的编号。但是hash算法也会面临容错性和扩展性

的问题。容错性是指当系统中的某个服务出现问题时，不能影响其他系统。扩展性是指当加入新的服务器后，整个系统能正确高效运行。

现假设有一台Redis服务器宕机了，那么为了填补空缺，要将宕机的服务器从编号列表中移除，后面的服务器按顺序前移一位并将其编号值减一，此时每个key
就要按 h = Hash(key) % 2 重新计算。

同样，如果新增一台服务器，规则也同样需要重新计算，h = Hash(key) % 4。
因此，系统中如果有服务器更变，会直接影响到Hash值，大量的key会重定向到其他服务器中，造成缓存命中率降低，而这种情况在分布式系统中是十分糟糕的。

一个设计良好的分布式哈希方案应该具有良好的单调性，即服务节点的变更不会造成大量的哈希重定位。一致性哈希算法由此而生~

### 3.2、一致性哈希算法

>一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中K是关键字的数
>量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。

简单的说，一致性哈希是将整个哈希值空间组织成一个虚拟的圆环，如假设哈希函数H的值空间为0-2^32-1（哈希值是32位无符号整形），整个哈希空间环
如下：

![image-20210914225757511](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210914225757511.png)

整个空间按顺时针方向组织，0和2^32-1在零点中方向重合。

接下来，把服务器按照IP或主机名作为关键字进行哈希，这样就能确定其在哈希环的位置。

![image-20210914225817935](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210914225817935.png)

然后，我们就可以使用哈希函数H计算值为key的数据在哈希环的具体位置h，根据h确定在环中的具体位置，从此位置沿顺时针滚动，遇到的第一台服务器就是其应该定位到的服务器。

例如我们有A、B、C、D四个数据对象，经过哈希计算后，在环空间上的位置如下：

![image-20210914225903420](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210914225903420.png)

根据一致性哈希算法，数据A会被定为到Server 1上，数据B被定为到Server 2上，而C、D被定为到Server 3上。

### 3.3、容错率和扩展性

那么使用一致性哈希算法的容错性和扩展性如何呢？

#### 3.3.1、容错性

假如RedisService2宕机了，那么会怎样呢？

![image-20210914225938831](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210914225938831.png)

那么，数据B对应的节点保存到RedisService3中。因此，其中一台宕机后，干扰的只有前面的数据（原数据被保存到顺时针的下一个服务器），而不会干扰到其他的数据。

#### 3.3.2、扩展性

下面考虑另一种情况，假如增加一台服务器Redis4，具体位置如下图所示：

![image-20210914230030430](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210914230030430.png)

原本数据C是保存到Redis3中，但由于增加了Redis4，数据C被保存到Redis4中。干扰的也只有Redis3而已，其他数据不会受到影响。
因此，一致性哈希算法对于节点的增减都只需重定位换空间的一小部分即可，具有较好的容错性和可扩展性

### 3.4、虚拟节点

前面部分都是讲述到Redis节点较多和节点分布较为均衡的情况，如果节点较少就会出现节点分布不均衡造成数据倾斜问题。

![image-20210914230111500](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210914230111500.png)

这会产生一种情况，Redis1的hash范围比Redis2的hash范围大，导致数据大部分都存储在Redis1中，数据存储不平衡。

为了解决这种数据存储不平衡的问题，一致性哈希算法引入了**虚拟节点机制**，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点称为**虚拟节点**。

具体做法可以在服务器IP或主机名的后面增加编号来实现，例如上面的情况，可以为每个服务节点增加三个虚拟节点，于是可以分为 RedisService1#1、RedisService1#2、 RedisService1#3、 RedisService2#1、RedisService2#2、 RedisService2#3，具体位置如下图所示：

![image-20210914230214009](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20210914230214009.png)

对于数据定位的hash算法仍然不变，只是增加了虚拟节点到实际节点的映射。例如，数据C保存到虚拟节点Redis1#2，实际上数据保存到Redis1中。这样，就能解决服务节点少时数据不平均的问题。在实际应用中，通常将虚拟节点数设置为**32甚至更大**，因此即使**很少的服务节点**也能做到**相对均匀的数据分布**。

## 4、分布式锁

### 4.1. 为什么使用分布式锁

我们在开发应用的时候，如果需要对某一个共享变量进行多线程同步访问的时候，可以使用我们学到的锁进行处理，并且可以完美的运行，毫无Bug！

注意这是单机应用，后来业务发展，需要做集群，一个应用需要部署到几台机器上然后做负载均衡，大致如下图：

<img src="https://gitee.com/yun-xiaojie/blog-image/raw/master/img/1350514-20190625021257274-823428432.png" style="zoom:50%">

上图可以看到，变量A存在三个服务器内存中（这个变量A主要体现是在一个类中的一个成员变量，是一个有状态的对象），如果不加任何控制的话，变量A同时都会在分配一块内存，三个请求发过来同时对这个变量操作，显然结果是不对的！即使不是同时发过来，三个请求分别操作三个不同内存区域的数据，变量A之间不存在共享，也不具有可见性，处理的结果也是不对的！

如果我们业务中确实存在这个场景的话，我们就需要一种方法解决这个问题！

为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用并发处理相关的功能进行互斥控制。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的应用并不能提供分布式锁的能力。为了解决这个问题就需要一种跨机器的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！

### 4.2 分布式锁具备条件

在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件：

1、在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；
2、高可用的获取锁与释放锁；
3、高性能的获取锁与释放锁；
4、具备可重入特性；
5、具备锁失效机制，防止死锁；
6、具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。

### 4.3 分布式锁的实现形式

分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。

#### 4.3.1 数据库实现

基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含**方法名**等字段，并在**方法名字段上创建唯一索引**，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。

1. 建表

   ```mysql
   DROP TABLE IF EXISTS `method_lock`;
   CREATE TABLE `method_lock` (
     `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
     `method_name` varchar(64) NOT NULL COMMENT '锁定的方法名',
     `desc` varchar(255) NOT NULL COMMENT '备注信息',
     `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
     PRIMARY KEY (`id`),
     UNIQUE KEY `uidx_method_name` (`method_name`) USING BTREE
   ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='锁定中的方法';
   ```

2. 想要执行某个方法，就使用这个方法名向表中插入数据：

   ```mysql
   INSERT INTO method_lock (method_name, desc) VALUES ('methodName', '测试的methodName');
   ```

   因为我们对`method_name`做了**唯一性约束**，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。

3. 成功插入则获取锁，执行完成后删除对应的行数据释放锁：

   ```mysql
   delete from method_lock where method_name ='methodName';
   ```

基于数据库的这种实现方式很简单，但是对于分布式锁应该具备的条件来说，它有一些问题需要解决及优化：

1、因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换；

2、不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁；

3、没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；

4、不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。

5、在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。

#### 4.3.2 Redis实现

>  选用 Redis 实现分布式锁原因：

- Redis有很高的性能；
- Redis命令对此支持较好，实现起来比较方便

>  使用命令介绍：

- `SETNX`
  - `SETNX key val`：当且仅当 `key` 不存在时，`set` 一个 `key` 为 `val` 的字符串，返回 `1` ；若 `key` 存在，则什么都不做，返回 `0` 。
- `expire`
  - `expire key timeout`：为 `key` 设置一个超时时间，单位为 `second` ，超过这个时间锁会自动释放，避免死锁。
- `delete`
  - `delete key`：删除 `key`

> 实现思想

- 获取锁的时候，使用 `setnx` 加锁，并使用 `expire` 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 `value` 值为一个随机生成的 `UUID` ，通过此在释放锁的时候进行判断。
- 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。
- 释放锁的时候，通过 `UUID` 判断是不是该锁，若是该锁，则执行 `delete` 进行锁释放。

#### 4.3.3 ZooKeeper的实现方式

ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。

> 基于ZooKeeper实现分布式锁的步骤如下：

- 创建一个目录 `mylock`；
- 线程 `A` 想获取锁就在 `mylock` 目录下创建临时顺序节点；
- 获取 `mylock` 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
- 线程 `B` 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
- 线程 `A` 处理完，删除自己的节点，线程 `B` 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。

这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。

优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。

缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。